var tipuesearch = {"pages":[{"title":" compare_reals_fortran ","text":"compare_reals_fortran","tags":"home","url":"index.html"},{"title":"eq_transfer – compare_reals_fortran","text":"public interface eq_transfer return all( transfer( x, 1, storage_size(x)/storage_size(1) ) .eq. transfer( y, 1, storage_size(x)/storage_size(1) ) ) Functions private pure elemental module function eq_transfer_real128(x, y) result(is_equal) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in) :: x real(kind=real128), intent(in) :: y Return Value logical private pure elemental module function eq_transfer_real32(x, y) result(is_equal) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x real(kind=real32), intent(in) :: y Return Value logical private pure elemental module function eq_transfer_real64(x, y) result(is_equal) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x real(kind=real64), intent(in) :: y Return Value logical","tags":"","url":"interface/eq_transfer.html"},{"title":"is_contained_by_next_out – compare_reals_fortran","text":"public interface is_contained_by_next_out return (ieee_next_down(x) .lt. y) .and. (y .lt. ieee_next_up(x)) Functions private pure elemental module function is_contained_by_next_out_real128(x, y) result(is_equal) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in) :: x real(kind=real128), intent(in) :: y Return Value logical private pure elemental module function is_contained_by_next_out_real32(x, y) result(is_equal) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x real(kind=real32), intent(in) :: y Return Value logical private pure elemental module function is_contained_by_next_out_real64(x, y) result(is_equal) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x real(kind=real64), intent(in) :: y Return Value logical","tags":"","url":"interface/is_contained_by_next_out.html"},{"title":"le_and_ge – compare_reals_fortran","text":"public interface le_and_ge return (x .le. y) .and. (x .ge. y) Functions private pure elemental module function le_and_ge_real128(x, y) result(is_equal) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in) :: x real(kind=real128), intent(in) :: y Return Value logical private pure elemental module function le_and_ge_real32(x, y) result(is_equal) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x real(kind=real32), intent(in) :: y Return Value logical private pure elemental module function le_and_ge_real64(x, y) result(is_equal) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x real(kind=real64), intent(in) :: y Return Value logical","tags":"","url":"interface/le_and_ge.html"},{"title":"compare_reals_fortran – compare_reals_fortran","text":"Uses ieee_class_fortran ieee_arithmetic iso_fortran_env Used by Descendants: compare_reals_fortran_eq_transfer compare_reals_fortran_is_contained_by_next_out compare_reals_fortran_le_and_ge Interfaces public        interface eq_transfer return all( transfer( x, 1, storage_size(x)/storage_size(1) ) .eq. transfer( y, 1, storage_size(x)/storage_size(1) ) ) private pure elemental module function eq_transfer_real128(x, y) result(is_equal) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in) :: x real(kind=real128), intent(in) :: y Return Value logical private pure elemental module function eq_transfer_real32(x, y) result(is_equal) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x real(kind=real32), intent(in) :: y Return Value logical private pure elemental module function eq_transfer_real64(x, y) result(is_equal) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x real(kind=real64), intent(in) :: y Return Value logical public        interface is_contained_by_next_out return (ieee_next_down(x) .lt. y) .and. (y .lt. ieee_next_up(x)) private pure elemental module function is_contained_by_next_out_real128(x, y) result(is_equal) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in) :: x real(kind=real128), intent(in) :: y Return Value logical private pure elemental module function is_contained_by_next_out_real32(x, y) result(is_equal) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x real(kind=real32), intent(in) :: y Return Value logical private pure elemental module function is_contained_by_next_out_real64(x, y) result(is_equal) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x real(kind=real64), intent(in) :: y Return Value logical public        interface le_and_ge return (x .le. y) .and. (x .ge. y) private pure elemental module function le_and_ge_real128(x, y) result(is_equal) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in) :: x real(kind=real128), intent(in) :: y Return Value logical private pure elemental module function le_and_ge_real32(x, y) result(is_equal) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x real(kind=real32), intent(in) :: y Return Value logical private pure elemental module function le_and_ge_real64(x, y) result(is_equal) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x real(kind=real64), intent(in) :: y Return Value logical","tags":"","url":"module/compare_reals_fortran.html"},{"title":"compare_reals_fortran_eq_transfer – compare_reals_fortran","text":"Uses Ancestors: compare_reals_fortran","tags":"","url":"module/compare_reals_fortran_eq_transfer.html"},{"title":"compare_reals_fortran_is_contained_by_next_out – compare_reals_fortran","text":"Uses Ancestors: compare_reals_fortran","tags":"","url":"module/compare_reals_fortran_is_contained_by_next_out.html"},{"title":"compare_reals_fortran_le_and_ge – compare_reals_fortran","text":"Uses Ancestors: compare_reals_fortran","tags":"","url":"module/compare_reals_fortran_le_and_ge.html"},{"title":"compare_reals_fortran.f90 – compare_reals_fortran","text":"Source Code module compare_reals_fortran use , intrinsic :: iso_fortran_env , only : real32 use , intrinsic :: iso_fortran_env , only : real64 use , intrinsic :: iso_fortran_env , only : real128 use , intrinsic :: ieee_arithmetic , only : ieee_negative_inf use , intrinsic :: ieee_arithmetic , only : ieee_next_after use , intrinsic :: ieee_arithmetic , only : ieee_positive_inf use , intrinsic :: ieee_arithmetic , only : ieee_value use , non_intrinsic :: ieee_class_fortran , only : is_ieee_either_zero use , non_intrinsic :: ieee_class_fortran , only : is_ieee_negative_inf use , non_intrinsic :: ieee_class_fortran , only : is_ieee_positive_inf implicit none private public :: eq_transfer public :: is_contained_by_next_out public :: le_and_ge interface eq_transfer !! version: experimental !! return `all( transfer( x, 1, storage_size(x)/storage_size(1) ) .eq. transfer( y, 1, storage_size(x)/storage_size(1) ) )` module pure elemental logical function eq_transfer_real32 ( x , y ) result ( is_equal ) real ( real32 ), intent ( in ) :: x , y end function eq_transfer_real32 module pure elemental logical function eq_transfer_real64 ( x , y ) result ( is_equal ) real ( real64 ), intent ( in ) :: x , y end function eq_transfer_real64 module pure elemental logical function eq_transfer_real128 ( x , y ) result ( is_equal ) real ( real128 ), intent ( in ) :: x , y end function eq_transfer_real128 end interface eq_transfer interface is_contained_by_next_out !! version: experimental !! return `(ieee_next_down(x) .lt. y) .and. (y .lt. ieee_next_up(x))` module pure elemental logical function is_contained_by_next_out_real32 ( x , y ) result ( is_equal ) real ( real32 ), intent ( in ) :: x , y end function is_contained_by_next_out_real32 module pure elemental logical function is_contained_by_next_out_real64 ( x , y ) result ( is_equal ) real ( real64 ), intent ( in ) :: x , y end function is_contained_by_next_out_real64 module pure elemental logical function is_contained_by_next_out_real128 ( x , y ) result ( is_equal ) real ( real128 ), intent ( in ) :: x , y end function is_contained_by_next_out_real128 end interface is_contained_by_next_out interface le_and_ge !! version: experimental !! return `(x .le. y) .and. (x .ge. y)` module pure elemental logical function le_and_ge_real32 ( x , y ) result ( is_equal ) real ( real32 ), intent ( in ) :: x , y end function le_and_ge_real32 module pure elemental logical function le_and_ge_real64 ( x , y ) result ( is_equal ) real ( real64 ), intent ( in ) :: x , y end function le_and_ge_real64 module pure elemental logical function le_and_ge_real128 ( x , y ) result ( is_equal ) real ( real128 ), intent ( in ) :: x , y end function le_and_ge_real128 end interface le_and_ge end module compare_reals_fortran","tags":"","url":"sourcefile/compare_reals_fortran.f90.html"},{"title":"compare_reals_fortran_eq_transfer.f90 – compare_reals_fortran","text":"Source Code submodule ( compare_reals_fortran ) compare_reals_fortran_eq_transfer implicit none contains module procedure eq_transfer_real32 is_equal = is_ieee_either_zero ( x ) . and . is_ieee_either_zero ( y ) if ( is_equal ) return associate ( & ! & storage_size_int => storage_size ( 1 ) , & ! & storage_size_real => storage_size ( x ) & ! ) associate ( array_size => storage_size_real / storage_size_int ) associate ( & ! & x_transferred => transfer ( source = x , mold = 1 , size = array_size ) , & ! & y_transferred => transfer ( source = y , mold = 1 , size = array_size ) & ! ) is_equal = all ( x_transferred (:) . eq . y_transferred (:) ) end associate end associate end associate end procedure eq_transfer_real32 module procedure eq_transfer_real64 is_equal = is_ieee_either_zero ( x ) . and . is_ieee_either_zero ( y ) if ( is_equal ) return associate ( & ! & storage_size_int => storage_size ( 1 ) , & ! & storage_size_real => storage_size ( x ) & ! ) associate ( array_size => storage_size_real / storage_size_int ) associate ( & ! & x_transferred => transfer ( source = x , mold = 1 , size = array_size ) , & ! & y_transferred => transfer ( source = y , mold = 1 , size = array_size ) & ! ) is_equal = all ( x_transferred (:) . eq . y_transferred (:) ) end associate end associate end associate end procedure eq_transfer_real64 module procedure eq_transfer_real128 is_equal = is_ieee_either_zero ( x ) . and . is_ieee_either_zero ( y ) if ( is_equal ) return associate ( & ! & storage_size_int => storage_size ( 1 ) , & ! & storage_size_real => storage_size ( x ) & ! ) associate ( array_size => storage_size_real / storage_size_int ) associate ( & ! & x_transferred => transfer ( source = x , mold = 1 , size = array_size ) , & ! & y_transferred => transfer ( source = y , mold = 1 , size = array_size ) & ! ) is_equal = all ( x_transferred (:) . eq . y_transferred (:) ) end associate end associate end associate end procedure eq_transfer_real128 end submodule compare_reals_fortran_eq_transfer","tags":"","url":"sourcefile/compare_reals_fortran_eq_transfer.f90.html"},{"title":"compare_reals_fortran_is_contained_by_next_out.f90 – compare_reals_fortran","text":"Source Code submodule ( compare_reals_fortran ) compare_reals_fortran_is_contained_by_next_out implicit none contains module procedure is_contained_by_next_out_real32 if ( is_ieee_negative_inf ( x ) ) then ; is_equal = is_ieee_negative_inf ( y ) else if ( is_ieee_positive_inf ( x ) ) then ; is_equal = is_ieee_positive_inf ( y ) else associate ( & ! ieee_negative_inf_x => ieee_value ( x = x , class = ieee_negative_inf ) , & ! ieee_positive_inf_x => ieee_value ( x = x , class = ieee_positive_inf ) & ! ) associate ( & ! ieee_next_down_x => ieee_next_after ( x = x , y = ieee_negative_inf_x ) , & ! ieee_next_up_x => ieee_next_after ( x = x , y = ieee_positive_inf_x ) & ! ) is_equal = ( ieee_next_down_x . lt . y ) & ! & . and . ( y . lt . ieee_next_up_x ) end associate end associate end if end procedure is_contained_by_next_out_real32 module procedure is_contained_by_next_out_real64 if ( is_ieee_negative_inf ( x ) ) then ; is_equal = is_ieee_negative_inf ( y ) else if ( is_ieee_positive_inf ( x ) ) then ; is_equal = is_ieee_positive_inf ( y ) else associate ( & ! ieee_negative_inf_x => ieee_value ( x = x , class = ieee_negative_inf ) , & ! ieee_positive_inf_x => ieee_value ( x = x , class = ieee_positive_inf ) & ! ) associate ( & ! ieee_next_down_x => ieee_next_after ( x = x , y = ieee_negative_inf_x ) , & ! ieee_next_up_x => ieee_next_after ( x = x , y = ieee_positive_inf_x ) & ! ) is_equal = ( ieee_next_down_x . lt . y ) & ! & . and . ( y . lt . ieee_next_up_x ) end associate end associate end if end procedure is_contained_by_next_out_real64 module procedure is_contained_by_next_out_real128 if ( is_ieee_negative_inf ( x ) ) then ; is_equal = is_ieee_negative_inf ( y ) else if ( is_ieee_positive_inf ( x ) ) then ; is_equal = is_ieee_positive_inf ( y ) else associate ( & ! ieee_negative_inf_x => ieee_value ( x = x , class = ieee_negative_inf ) , & ! ieee_positive_inf_x => ieee_value ( x = x , class = ieee_positive_inf ) & ! ) associate ( & ! ieee_next_down_x => ieee_next_after ( x = x , y = ieee_negative_inf_x ) , & ! ieee_next_up_x => ieee_next_after ( x = x , y = ieee_positive_inf_x ) & ! ) is_equal = ( ieee_next_down_x . lt . y ) & ! & . and . ( y . lt . ieee_next_up_x ) end associate end associate end if end procedure is_contained_by_next_out_real128 end submodule compare_reals_fortran_is_contained_by_next_out","tags":"","url":"sourcefile/compare_reals_fortran_is_contained_by_next_out.f90.html"},{"title":"compare_reals_fortran_le_and_ge.f90 – compare_reals_fortran","text":"Source Code submodule ( compare_reals_fortran ) compare_reals_fortran_le_and_ge implicit none contains module procedure le_and_ge_real32 is_equal = ( x . le . y ) . and . ( x . ge . y ) end procedure le_and_ge_real32 module procedure le_and_ge_real64 is_equal = ( x . le . y ) . and . ( x . ge . y ) end procedure le_and_ge_real64 module procedure le_and_ge_real128 is_equal = ( x . le . y ) . and . ( x . ge . y ) end procedure le_and_ge_real128 end submodule compare_reals_fortran_le_and_ge","tags":"","url":"sourcefile/compare_reals_fortran_le_and_ge.f90.html"}]}